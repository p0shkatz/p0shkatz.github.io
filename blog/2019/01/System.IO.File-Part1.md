This is the first blog in a series where I talk about my favorite .NET class of 2018. For a while now, I have been intrigued with the simple capabilities of System.IO.File. It invokes some of the basic input/output Windows APIs used to read and write data. As you can guess, this is used heavily by C# developers. I'm going to veer slightly (SQUIRREL!) before we get back to File.

A few years ago when I was working as a blue teamer helping product owners secure their platform and their products, we needed to figure out was overwriting a configuration file. We assumed a legitimate process was doing it, but the vendor could not explain what was causing the behavior. This was my introduction to the (System.IO) FileSystemWatcher class. Using FileSystemWatcher and file auditing, we were able to isolate the offending process (and user) and add some automation to replace the modification with our original values.

So how does it work? FileSystemWatcher works using specific event triggers. From Microsoft.com, "Listens to the file system change notifications and raises events when a directory, or file in a directory, changes." Specifically, a listener can be configured to monitor when files and/or directories are created, changed, deleted, renamed, or on file system errors. FileSystemWatchers can be targeted or filtered and they also support recursive files and directories. This helped us identify a bug in the product and the vendor quickly responded with a patch.

Flash forward a few more years. I was pentesting an application that was invoked by a userland client over a named pipe (more on named pipes in another blog). The named pipe server would receive parameters from the client, request additional details from a web service, and then write out commands to a batch file on the local file system. The batch file was then executed by the service running the named pipe server. The service was running as LOCAL SYSTEM. The batch file had an access control entry that allowed Authenticated Users to Modify the file. The problem was timing. Enter Indiana Jones meme. By the time the file was written, it was executed in a matter of milliseconds.

Once I figured out the logic of the service, I wrote a FileSystemWatcher script in PowerShell that would wait for the OnCreated (initial file handle is created) and OnChanged (data is actually committed to disk) events. At that point, the script grabs the MD5 hash of the batch file and stores that for comparison later. Next, the PowerShell script copies over my evil batch file, replacing the legitimate file. Lastly, it compares the current batch MD5 with the legitimate MD5. If the current MD5 does not match our evil MD5, it continues to copy (loop). I did not know what to do with it, so I simply had run a reverse PowerShell shell and connect to my hacktop.

Eventing in Windows is a powerful concept. File system events are only one part of it. As always, if you want to learn more, I recommend reading up on the official Microsoft documentation. Below is a link to the script I used.
